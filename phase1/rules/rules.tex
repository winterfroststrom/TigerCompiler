\documentclass[11pt, fleqn]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{parskip}
\usepackage{subfigure}
\usepackage[margin=0.5in]{geometry}
\usepackage{dot2texi}
\usepackage{tikz}
\usepackage{longtable}
\usetikzlibrary{shapes,arrows}
\usepackage{sectsty}

% always have Definitions.sty handy
\usepackage{Definitions}

\def \union {\cup}
\def \intersect {\cap}
\def \Union {\bigcup}
\def \Intersect {\bigcap}
\def \And {\wedge}
\def \Or {\vee}
\def \st {\text{ s.t. }}
\def \blank {\sqcup}

\newcommand{\atag}[1]{$\langle$#1$\rangle$}

%\allsectionsfont{\normalfont}
\setlength{\parindent}{0cm}

\begin{document}

\title{CS 4240 Phase 1}
\author{David Zhang}
\date{\today}

\newtheorem{Lemma}{Lemma}
\newtheorem{Theorem}{Theorem}
\maketitle

The lexer/parser is run by compiling all the Java files and running the General.Runner class.
The program takes in one argument for the tiger file, which must have a .tiger extension.
The program outputs two files programname.tokens and programname.tokens.err, the first is a list of tokens.
The second is any error output if it exists.

\section{Lexical Rules}

Pre-parse the input to remove comments with the following DFA. The resulting NOT-COMMENT tokens are concatenated together.

Everything under the token column represents either generated tokens or custom table actions on the character buffer used to produce the text associated with tokens.

\begin{longtable}{l|l|l|l}
start state		&	symbol							&	next	 state		&	token		 	\\
\hline
START			&	$\Sigma - \{/, "\}$				& 	START			&	NOT-COMMENT		\\
START			&	``								& 	STRING			&					\\
START			&	/								&	SLASH			&					\\
STRING			&	$\Sigma - \{\backslash, "\}$		& 	STRING			&					\\
STRING			&	\textbackslash					& 	STRING-SLASH		&					\\
STRING			&	''								& 	START			&	NOT-COMMENT		\\
STRING-SLASH		&	$\Sigma$							&	STRING			&					\\
SLASH			&	$\Sigma - \{*\}$					&	START			&	NOT-COMMENT		\\
SLASH			&	*								&	COMMENT			&					\\
COMMENT			&	$\Sigma - \{*\}$					&	COMMENT			&					\\
COMMENT			&	*								&	COMMENT-END		&					\\
COMMENT-END		&	$\Sigma - \{*, /\}$				&	COMMENT			&					\\
COMMENT-END		&	*								&	COMMENT-END		&					\\
COMMENT-END		&	/								&	START			&	COMMENT			\\
\end{longtable}

The DFA for uncommented code.

Note, any time backtracking is mentioned, it essentially is the same as treating the current state as the start state and doing the corresponding transitions or token generations. This is included to simplify the table by removing duplication of the start state transitions.

Note, all ids are later matched character by character with keywords to determine if they are keywords.

Note, drop character for the error state means that the last read character is ignored, and the state remains unchanged.

\begin{longtable}{l|l|l|l}
start state		&	symbol						&	next	 state		&	token		 		\\
\hline
START			&	+								&	START			&	PLUS					\\
START			&	-								&	START			&	MIN					\\
START			&	*								&	START			&	MULT					\\
START			&	/								&	START			&	DIV					\\
START			&	=								&	START			&	EQ					\\
START			&	(								&	START			&	LPAREN				\\
START			&	)								&	START			&	RPAREN				\\
START			&	,								&	START			&	COMMA				\\
START			&	\&								&	START			&	AND					\\
START			&	|								&	START			&	OR					\\
START			&	[								&	START			&	LSQUARE				\\
START			&	]								&	START			&	RSQUARE				\\
%START			&	\{								&	START			&	LCURLY				\\
%START			&	\}								&	START			&	RCURLY				\\
START			&	;								&	START			&	SEMI					\\
START			&	$\langle$						&	LANGLE			&						\\
START			&	$\rangle$						&	RANGLE			&						\\
START			&	:								&	COLON			&						\\
START			&	0-9								&	INT-LIT			&						\\
START			&	``								&	STRING-LIT		&						\\
START			&	a-zA-Z							&	ID				&						\\
START			&	whitespace						&	START			&	ignore				\\
START			&	others							&	ERROR			&	drop character		\\
LANGLE			&	$\Sigma - \{=, \rangle\}$		&	START			&	LESS	, backtrack		\\
LANGLE			&	$\rangle$						&	START			&	NOTEQ				\\
LANGLE			&	=								&	START			&	LESSEQ				\\
RANGLE			&	$\Sigma - \{=\}$					&	START			&	GREATER, backtrack	\\
RANGLE			&	=								&	START			&	GREATEREQ			\\
COLON			&	=								&	START			&	ASSIGN				\\
COLON			&	$\Sigma - \{=\}$					&	START			&	COLON, backtrack		\\
INT-LIT			&	0-9								&	INT-LIT			&						\\
INT-LIT			&	$\Sigma - 0-9	$				&	START			&	INT-LIT, backtrack	\\
ID				&	a-zA-Z0-9\_						&	ID				&						\\
ID				&	$\Sigma - a-zA-Z0-9\_$			&	START			&	ID, backtrack		\\
STRING-LIT			&	$\Sigma - {\backslash}$	&	STRING-LIT			&						\\
STRING-LIT			&	''						&	START				&	STRING-LIT			\\
STRING-LIT			&	\textbackslash			&	STRING-LIT-SLASH		&						\\
STRING-LIT-SLASH		&	n						&	STRING-LIT			&						\\
STRING-LIT-SLASH		&	t						&	STRING-LIT			&								\\
STRING-LIT-SLASH		&	''						&	STRING-LIT			&								\\
STRING-LIT-SLASH		&	\textbackslash			&	STRING-LIT			&								\\
STRING-LIT-SLASH		&	\textasciicircum			&	STRING-LIT-CTL		&								\\
STRING-LIT-SLASH		&	0-9						&	STRING-LIT-CODE-1	&					\\
STRING-LIT-SLASH		&	whitespace				&	STRING-LIT-SPACE		& ignore 2 characters			\\
STRING-LIT-SLASH		&	others					&	ERROR				& drop character				\\
STRING-LIT-CTL		&	@A-Z[\textbackslash]\textasciicircum\_ .		&	STRING-LIT			&			\\
STRING-LIT-CTL		&	others					&	ERROR				& drop character					\\
STRING-LIT-CODE-1	&	0-9						&	STRING-LIT-CODE-2			&					\\
STRING-LIT-CODE-1	&	others					&	ERROR			&	drop character				\\
STRING-LIT-CODE-2	&	0-9						&	STRING-LIT		&								\\
STRING-LIT-CODE-2	&	others					&	ERROR			&	drop character				\\
STRING-LIT-SPACE		&	whitespace				&	STRING-LIT-SPACE		& ignore							\\
STRING-LIT-SPACE		&	\textbackslash			&	STRING-LIT			& ignore							\\
STRING-LIT-SPACE		&	others					&	ERROR				& drop character				\\
\end{longtable}

\section{Grammar Rules}

Raw Grammar:

\begin{longtable}{l|l}
symbol							&	rule								\\
\hline
\atag{tiger-program}				&	let \atag{declaration-segment} in \atag{stat-seq} end				\\
\atag{declaration-segment}		&	\atag{type-declaration-list}	\atag{var-declaration-list} \atag{funct-declaration-list}	\\
\atag{type-declaration-list}		&	\atag{type-declaration} \atag{type-declaration-list}	\\
\atag{type-declaration-list}		&	NULL		\\
\atag{var-declaration-list}		&	\atag{var-declaration} \atag{var-declaration-list}	\\
\atag{var-declaration-list}		&	NULL		\\
\atag{funct-declaration-list}	&	\atag{funct-declaration} \atag{funct-declaration-list}	\\
\atag{funct-declaration-list}	&	NULL		\\
\atag{type-declaration}			&	type id = \atag{type} ;		\\
\atag{type}						&	\atag{type-id}		\\
%\atag{type}						&	array [ INTLIT ] of \atag{type-id}		\\
\atag{type}						&	array [ INTLIT ] \atag{type-dim} of \atag{type-id}	\\
\atag{type-dim}					&	[ INTLIT ] \atag{type-dim}	\\
\atag{type-dim}					&	NULL		\\
\atag{type-id}					&	int		\\
\atag{type-id}					&	string		\\
\atag{type-id}					&	id		\\
\atag{var-declaration}			&	var \atag{id-list} : \atag{type-id} \atag{optional-init} ;		\\
\atag{id-list}					&	id		\\
\atag{id-list}					&	id , \atag{id-list}		\\
\atag{optional-init}				&	NULL		\\
\atag{optional-init}				&	:= \atag{const}		\\
\atag{funct-declaration}			&	function id ( \atag{param-list} ) \atag{ret-type} begin \atag{stat-seq} end ;	\\
\atag{param-list}				&	NULL		\\
\atag{param-list}				&	\atag{param}	 \atag{param-list-tail}	\\
\atag{param-list-tail}			&	NULL		\\
\atag{param-list-tail}			&	, \atag{param} \atag{param-list-tail}		\\
\atag{ret-type}					&	NULL		\\
\atag{ret-type}					&	: \atag{type-id}		\\
\atag{param}						&	id : \atag{type-id}		\\
\atag{stat-seq}					&	\atag{stat} \atag{stat-seq}		\\
\atag{stat-seq}					&	\atag{stat}		\\
\atag{stat}						&	\atag{lvalue} := \atag{expr}	;	\\
\atag{stat}						&	if \atag{expr} then \atag{stat-seq} endif ;		\\
\atag{stat}						&	if \atag{expr} then \atag{stat-seq} else \atag{stat-seq} endif ;		\\
\atag{stat}						&	while \atag{expr} do \atag{stat-seq} enddo ;		\\
\atag{stat}						&	for id := \atag{expr} to \atag{expr} do \atag{stat-seq} enddo ;		\\
%\atag{stat}						&	id ( \atag{expr-list} ) ;		\\
\atag{stat}						&	\atag{opt-prefix} id ( \atag{expr-list} ) ; \\
\atag{stat}						&	break ;		\\
\atag{stat}						&	return \atag{expr} ;		\\
\atag{expr}						&	\atag{expr} \atag{binary-operator} \atag{expr}		\\
\atag{expr}						&	\atag{const}		\\
\atag{expr}						&	\atag{lvalue}		\\
\atag{expr}						&	- \atag{expr}		\\
\atag{expr}						&	( \atag{expr} )		\\
\atag{binary-operator}			&	*	\\
\atag{binary-operator}			&	/	\\
\atag{binary-operator}			&	+	\\
\atag{binary-operator}			&	-	\\
\atag{binary-operator}			&	=	\\
\atag{binary-operator}			&	$<$	\\
\atag{binary-operator}			&	$>$	\\
\atag{binary-operator}			&	$<=$	\\
\atag{binary-operator}			&	$>=$	\\
\atag{binary-operator}			&	$<>$	\\
\atag{binary-operator}			&	\&	\\
\atag{binary-operator}			&	\textbar		\\
\atag{binary-operator}			&	:=	\\
\atag{opt-prefix}				&	\atag{lvalue} :=		\\
\atag{opt-prefix}				&	NULL		\\
\atag{const}						&	INTLIT		\\
\atag{const}						&	STRLIT		\\
\atag{const}						&	nil		\\
\atag{expr-list}					&	\atag{expr} \atag{expr-list-tail}		\\
\atag{expr-list}					&	NULL		\\
\atag{expr-list-tail}			&	, \atag{expr} \atag{expr-list-tail}		\\
\atag{expr-list-tail}			&	NULL		\\
\atag{lvalue}					&	id \atag{lvalue-tail}		\\
\atag{lvalue-tail}				&	[ \atag{expr} ] \atag{lvalue-tail}		\\
\atag{lvalue-tail}				&	NULL		\\
\end{longtable}

Modified Grammar:

\begin{longtable}{l|l}
symbol							&	rule								\\
\hline
\atag{tiger-program}				&	let \atag{declaration-segment} in \atag{stat-seq} end				\\
\atag{declaration-segment}		&	\atag{type-declaration-list}	\atag{var-declaration-list} \atag{funct-declaration-list}	\\
\atag{type-declaration-list}		&	\atag{type-declaration} \atag{type-declaration-list}	\\
\atag{type-declaration-list}		&	NULL		\\
\atag{var-declaration-list}		&	\atag{var-declaration} \atag{var-declaration-list}	\\
\atag{var-declaration-list}		&	NULL		\\
\atag{funct-declaration-list}	&	\atag{funct-declaration} \atag{funct-declaration-list}	\\
\atag{funct-declaration-list}	&	NULL		\\
\atag{type-declaration}			&	type id = \atag{type} ;		\\
\atag{var-declaration}			&	var \atag{id-list} : \atag{type-id} \atag{optional-init} ;		\\
\atag{funct-declaration}			&	function id ( \atag{param-list} ) \atag{ret-type} begin \atag{stat-seq} end ;	\\
\atag{type}						&	\atag{type-id}		\\
\atag{type}						&	array [ INTLIT ] \atag{type-dim} of \atag{type-id}	\\
\atag{type-dim}					&	[ INTLIT ] \atag{type-dim}	\\
\atag{type-dim}					&	NULL		\\
\atag{type-id}					&	id		\\
\atag{id-list}					&	id \atag{id-list-tail}		\\
\atag{id-list-tail}				&	, id \atag{id-list-tail}		\\
\atag{id-list-tail}				&	NULL		\\
\atag{optional-init}				&	:= \atag{const}		\\
\atag{optional-init}				&	NULL		\\
\atag{param-list}				&	\atag{param}	 \atag{param-list-tail}	\\
\atag{param-list}				&	NULL		\\
\atag{param-list-tail}			&	, \atag{param} \atag{param-list-tail}		\\
\atag{param-list-tail}			&	NULL		\\
\atag{ret-type}					&	: \atag{type-id}		\\
\atag{ret-type}					&	NULL		\\
\atag{param}						&	id : \atag{type-id}		\\
\atag{stat-seq}					&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq-tail}				&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq-tail}				&	NULL		\\
\atag{stat}						&	if \atag{expr} then \atag{stat-seq} \atag{stat-if-tail}		\\
\atag{stat}						&	while \atag{expr} do \atag{stat-seq} enddo ;		\\
\atag{stat}						&	for id := \atag{expr} to \atag{expr} do \atag{stat-seq} enddo ;		\\
\atag{stat}						&	break ;		\\
\atag{stat}						&	return \atag{expr} ;		\\
\atag{stat}						&	id \atag{stat-func-or-assign}	\\
\atag{stat-func-or-assign}		&	( \atag{expr-list} ) ;	\\
\atag{stat-func-or-assign}		&	\atag{lvalue-tail} := \atag{stat-assign}	;	\\
\atag{stat-if-tail}				&	else \atag{stat-seq} endif ;		\\
\atag{stat-if-tail}				&	endif ;		\\
\atag{stat-assign}				&	- \atag{unaryminus} \atag{stat-assign-tail}	\\
\atag{stat-assign}				&	( \atag{expr} ) \atag{stat-assign-tail}	\\
\atag{stat-assign}				&	\atag{const}	 \atag{stat-assign-tail}		\\
\atag{stat-assign}				&	id \atag{stat-assign-id}	\\
\atag{stat-assign-id}			&	( \atag{expr-list} )		\\
\atag{stat-assign-id}			&	\atag{lvalue-tail} \atag{stat-assign-tail}	\\
\atag{stat-assign-tail}			&	\atag{expr-tail}		\\
\atag{stat-assign-tail}			&	\atag{orexpr-tail}		\\
\atag{stat-assign-tail}			&	\atag{andexpr-tail}		\\
\atag{stat-assign-tail}			&	\atag{compare-tail}		\\
\atag{stat-assign-tail}			&	\atag{term-tail}		\\
\atag{expr}						&	\atag{orexpr} \atag{expr-tail}		\\
\atag{expr-tail}					&	\atag{orop} \atag{orexpr} \atag{expr-tail}	\\
\atag{expr-tail}					&	NULL		\\
\atag{orexpr} 					&	\atag{andexpr} \atag{orexpr-tail}		\\
\atag{orexpr-tail}				&	\atag{andop} \atag{andexpr} \atag{orexpr-tail}	\\
\atag{orexpr-tail}				&	NULL	\\
\atag{andexpr} 					&	\atag{compare} \atag{andexpr-tail}		\\
\atag{andexpr-tail}				&	\atag{compop} \atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	NULL	\\
\atag{compare} 					&	\atag{term} \atag{compare-tail}		\\
\atag{compare-tail}				&	\atag{addop} \atag{term} \atag{compare-tail}	\\
\atag{compare-tail}				&	NULL	\\
\atag{term} 						&	\atag{factor} \atag{term-tail}		\\
\atag{term-tail}					&	\atag{mulop} \atag{factor} \atag{term-tail}	\\
\atag{term-tail}					&	NULL	\\
\atag{factor}					&	\atag{unaryminus}		\\
\atag{factor}					&	- \atag{unaryminus}		\\
\atag{unaryminus}				&	( \atag{expr} )		\\
\atag{unaryminus}				&	\atag{const}		\\
\atag{unaryminus}				&	\atag{lvalue}		\\
\atag{const}						&	INTLIT		\\
\atag{const}						&	STRLIT		\\
\atag{const}						&	nil		\\
\atag{orop} 						&	\textbar		\\
\atag{andop}						&	\&		\\
\atag{compop}					&	=		\\
\atag{compop}					&	$<>$		\\
\atag{compop}					&	$>$		\\
\atag{compop}					&	$<$		\\
\atag{compop}					&	$>=$		\\
\atag{compop}					&	$<=$		\\
\atag{addop}						&	+		\\
\atag{addop}						&	-		\\
\atag{mulop}						&	*		\\
\atag{mulop}						&	/		\\
\atag{expr-list}					&	\atag{expr} \atag{expr-list-tail}		\\
\atag{expr-list}					&	NULL		\\
\atag{expr-list-tail}			&	, \atag{expr} \atag{expr-list-tail}		\\
\atag{expr-list-tail}			&	NULL		\\
\atag{lvalue}					&	id \atag{lvalue-tail}		\\
\atag{lvalue-tail}				&	[ \atag{expr} ] \atag{lvalue-tail}		\\
\atag{lvalue-tail}				&	NULL		\\
\end{longtable}


\begin{longtable}{l|l}
non-terminal						&	first set												\\
\hline
\atag{lvalue-tail}				&	[, $\epsilon$												\\
\atag{lvalue}					&	id														\\
\atag{expr-list-tail}			&	,, $\epsilon$												\\
\atag{expr-list}					&	(, nil, STRLIT, INTLIT, id, -, $\epsilon$				\\
\atag{mulop}						&	*, /														\\
\atag{addop}						&	+, -														\\
\atag{compop}					&	$=, <, >, <=, >=, <>$									\\
\atag{andop}						&	\&														\\
\atag{orop} 						&	\textbar		\\
\atag{const}						&	nil, STRLIT, INTLIT		\\
\atag{unaryminus}				&	(, nil, STRLIT, INTLIT, id		\\
\atag{factor}					&	(, nil, STRLIT, INTLIT, id, -		\\
\atag{term-tail}					&	*, /	, $\epsilon$	\\
\atag{term} 						&	(, nil, STRLIT, INTLIT, id, -		\\
\atag{compare-tail}				&	+, -, $\epsilon$	\\
\atag{compare} 					&	(, nil, STRLIT, INTLIT, id, -		\\
\atag{andexpr-tail}				&	$=, <, >, <=, >=, <>$, $\epsilon$	\\
\atag{andexpr} 					&	(, nil, STRLIT, INTLIT, id, -		\\
\atag{orexpr} 					&	(, nil, STRLIT, INTLIT, id, -		\\
\atag{orexpr-tail}				&	\& , $\epsilon$	\\
\atag{expr}						&	(, nil, STRLIT, INTLIT, id, -		\\
\atag{expr-tail}					&	\textbar	, $\epsilon$	\\
\atag{stat-assign}				&	id, -, (, nil, STRLIT, INTLIT	\\
\atag{stat-assign-id}			&	[, (, *, /, +, -, $=, <, >, <=, >=, <>$, \& , \textbar , $\epsilon	$\\
\atag{stat-assign-tail}			&	*, /	, +, -, $=, <, >, <=, >=, <>$, \& , \textbar , $\epsilon$	\\
\atag{stat-if-tail}				&	else, endif		\\
\atag{stat-func-or-assign}		&	(, :=, [		\\
\atag{stat}						&	if, while, for, break, return, id		\\
\atag{stat-seq}					&	if, while, for, break, return, id		\\
\atag{stat-seq-tail}				&	if, while, for, break, return, id, $\epsilon$		\\
\atag{param}						&	id		\\
\atag{ret-type}					&	:, $\epsilon	$	\\
\atag{param-list-tail}			&	,, $\epsilon$		\\
\atag{param-list}				&	id, $\epsilon$		\\
\atag{optional-init}				&	:=, $\epsilon$		\\
\atag{id-list-tail}				&	,, $\epsilon$		\\
\atag{id-list}					&	id		\\
\atag{type-id}					&	id		\\
\atag{type-dim}					&	[, $\epsilon$	\\
\atag{type}						&	array, id		\\
\atag{funct-declaration}			&	function		\\
\atag{var-declaration}			&	var \\
\atag{type-declaration}			&	type 		\\
\atag{funct-declaration-list}	&	function, $\epsilon$	\\
\atag{var-declaration-list}		&	var, $\epsilon$	\\
\atag{type-declaration-list}		&	type, $\epsilon$		\\
\atag{declaration-segment}		&	function, var, type, $\epsilon$	\\
\atag{tiger-program}				&	let				\\
\end{longtable}

\begin{longtable}{l|l}
non-terminal						&	follow set												\\
\hline
\atag{lvalue-tail}				&	:=, *, /	, +, -, $=, <, >, <=, >=, <>$, \& , \\
\atag{lvalue-tail}				&	\textbar , ), ,, , ], then, do, to, ; 	\\
\atag{expr-list-tail}			&	)												\\
\atag{expr-list}					&	)								\\
\atag{expr-tail}					&	), ,, , ], then, do, to, ;	\\
\atag{orexpr-tail}				&	\textbar , ), ,, , ], then, do, to, ;	\\
\atag{andexpr-tail}				&	\& ,\textbar , ), ,, ], then, do, to, ; 	\\
\atag{compare-tail}				&	\& ,\textbar , ), ,, ], then, do, to, ;, $=, <, >, <=, >=, <>$	\\
\atag{term-tail}					&	\& ,\textbar , ), ,, ], then, do, to, ;, $=, <, >, <=, >=, <>$, +, -	\\
\atag{term-tail}					&	\\
\atag{stat-assign-tail}			&	;	\\
\atag{stat-assign-id}			&	;	\\
\atag{stat-seq-tail}				&	endif, end, enddo, else		\\
\atag{ret-type}					&	begin		\\
\atag{param-list-tail}			&	)	\\
\atag{param-list}				&	)		\\
\atag{optional-init}				&	;		\\
\atag{id-list-tail}				&	:		\\
\atag{type-dim}					&	of	\\
\atag{funct-declaration-list}	&	in	\\
\atag{var-declaration-list}		&	function, in	\\
\atag{type-declaration-list}		&	var, function, in		\\
\atag{declaration-segment}		&	in	\\
\end{longtable}


Note, if there is no corresponding rule, then that means a parser error is generated.

Note, errors are handled by dropping tokens until a valid token is found.

\begin{longtable}{l|l|l}
symbol							&	next token	&	rule									\\
\hline
\atag{addop}						&	+			&	+									\\
\atag{addop}						&	-			&	-									\\
\atag{andexpr} 					&	(			&	\atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr} 					&	nil			&	\atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr} 					&	STRLIT		&	\atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr} 					&	INTLIT		&	\atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr} 					&	id			&	\atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr} 					&	-			&	\atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	$=$			&	\atag{compop} \atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	$<$			&	\atag{compop} \atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	$>$			&	\atag{compop} \atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	$>=$			&	\atag{compop} \atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	$<=$			&	\atag{compop} \atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	$<>$			&	\atag{compop} \atag{compare} \atag{andexpr-tail}	\\
\atag{andexpr-tail}				&	\&			&	$\epsilon$	\\
\atag{andexpr-tail}				&	\textbar		&	$\epsilon$	\\
\atag{andexpr-tail}				&	)			&	$\epsilon$	\\
\atag{andexpr-tail}				&	,			&	$\epsilon$	\\
\atag{andexpr-tail}				&	]			&	$\epsilon$	\\
\atag{andexpr-tail}				&	then			&	$\epsilon$	\\
\atag{andexpr-tail}				&	do			&	$\epsilon$	\\
\atag{andexpr-tail}				&	to			&	$\epsilon$	\\
\atag{andexpr-tail}				&	;			&	$\epsilon$	\\
\atag{andop}						&	\&			&	\&										\\
\atag{compare} 					&	(			&	\atag{term} \atag{compare-tail}	\\
\atag{compare} 					&	nil			&	\atag{term} \atag{compare-tail}	\\
\atag{compare} 					&	STRLIT		&	\atag{term} \atag{compare-tail}	\\
\atag{compare} 					&	INTLIT		&	\atag{term} \atag{compare-tail}	\\
\atag{compare} 					&	id			&	\atag{term} \atag{compare-tail}	\\
\atag{compare} 					&	-			&	\atag{term} \atag{compare-tail}	\\
\atag{compare-tail}				&	+			&	\atag{addop} \atag{term} \atag{compare-tail}	\\
\atag{compare-tail}				&	-			&	\atag{addop} \atag{term} \atag{compare-tail}	\\
\atag{compare-tail}				&	\&			&	$\epsilon$					\\
\atag{compare-tail}				&	\textbar			&	$\epsilon$					\\
\atag{compare-tail}				&	)			&	$\epsilon$					\\
\atag{compare-tail}				&	,			&	$\epsilon$					\\
\atag{compare-tail}				&	]			&	$\epsilon$					\\
\atag{compare-tail}				&	then			&	$\epsilon$					\\
\atag{compare-tail}				&	do			&	$\epsilon$					\\
\atag{compare-tail}				&	to			&	$\epsilon$					\\
\atag{compare-tail}				&	;			&	$\epsilon$					\\
\atag{compare-tail}				&	$=$			&	$\epsilon$					\\
\atag{compare-tail}				&	$<$			&	$\epsilon$					\\
\atag{compare-tail}				&	$>$			&	$\epsilon$					\\
\atag{compare-tail}				&	$<=$			&	$\epsilon$					\\
\atag{compare-tail}				&	$>=$			&	$\epsilon$					\\
\atag{compare-tail}				&	$<>$			&	$\epsilon$						\\
\atag{compop}					&	$=$			&	$=$								\\
\atag{compop}					&	$<$			&	$<$								\\
\atag{compop}					&	$>$			&	$>$								\\
\atag{compop}					&	$<=$			&	$<=$								\\
\atag{compop}					&	$>=$			&	$>=$								\\
\atag{compop}					&	$<>$			&	$<>$								\\
\atag{const}						&	nil			&	nil	\\
\atag{const}						&	STRLIT		&	STRLIT	\\
\atag{const}						&	INTLIT		&	INTLIT	\\
\atag{declaration-segment}		&	function		&	\atag{type-declaration-list}	\atag{var-declaration-list} \atag{funct-declaration-list}	\\
\atag{declaration-segment}		&	var			&	\atag{type-declaration-list}	\atag{var-declaration-list} \atag{funct-declaration-list}	\\
\atag{declaration-segment}		&	type			&	\atag{type-declaration-list}	\atag{var-declaration-list} \atag{funct-declaration-list}	\\
\atag{declaration-segment}		&	in			&	$\epsilon$	\\
\atag{expr-list}					&	)			&	$\epsilon$				\\
\atag{expr-list}					&	(			&	\atag{expr} \atag{expr-list-tail}				\\
\atag{expr-list}					&	nil			&	\atag{expr} \atag{expr-list-tail}				\\
\atag{expr-list}					&	STRLIT		&	\atag{expr} \atag{expr-list-tail}				\\
\atag{expr-list}					&	INTLIT			&	\atag{expr} \atag{expr-list-tail}				\\
\atag{expr-list}					&	id			&	\atag{expr} \atag{expr-list-tail}				\\
\atag{expr-list}					&	-			&	\atag{expr} \atag{expr-list-tail}				\\
\atag{expr-list-tail}			&	)			&	$\epsilon$								\\
\atag{expr-list-tail}			&	,			&	, \atag{expr} \atag{expr-list-tail}		\\
\atag{expr}						&	(			&	\atag{orexpr} \atag{expr-tail}	\\
\atag{expr}						&	nil			&	\atag{orexpr} \atag{expr-tail}	\\
\atag{expr}						&	STRLIT			&	\atag{orexpr} \atag{expr-tail}	\\
\atag{expr}						&	INTLIT			&	\atag{orexpr} \atag{expr-tail}	\\
\atag{expr}						&	id			&	\atag{orexpr} \atag{expr-tail}	\\
\atag{expr}						&	-			&	\atag{orexpr} \atag{expr-tail}	\\
\atag{expr-tail}					&	)		&	$\epsilon$		\\
\atag{expr-tail}					&	,		&	$\epsilon$		\\
\atag{expr-tail}					&	]		&	$\epsilon$		\\
\atag{expr-tail}					&	then		&	$\epsilon$		\\
\atag{expr-tail}					&	do		&	$\epsilon$		\\
\atag{expr-tail}					&	to		&	$\epsilon$		\\
\atag{expr-tail}					&	;		&	$\epsilon$		\\
\atag{factor}					&	(		&	\atag{unaryminus}		\\
\atag{factor}					&	nil		&	\atag{unaryminus}		\\
\atag{factor}					&	STRLIT	&	\atag{unaryminus}		\\
\atag{factor}					&	INTLIT	&	\atag{unaryminus}		\\
\atag{factor}					&	id		&	\atag{unaryminus}		\\
\atag{factor}					&	-		&	- \atag{unaryminus}		\\
\atag{funct-declaration}			&	function		&	function id ( \atag{param-list} ) \atag{ret-type} begin \atag{stat-seq} end ;	\\
\atag{funct-declaration-list}	&	function		&	\atag{funct-declaration} \atag{funct-declaration-list}	\\
\atag{funct-declaration-list}	&	in		&	$\epsilon$	\\
\atag{id-list}					&	id		&	id \atag{id-list-tail}	\\
\atag{id-list-tail}				&	:		&	$\epsilon$	\\
\atag{id-list-tail}				&	,		&	, id \atag{id-list-tail}	\\
\atag{lvalue}					&	id		&	id \atag{lvalue-tail}			\\
\atag{lvalue-tail}				&	[		&	[ \atag{expr} ] \atag{lvalue-tail}		\\
\atag{lvalue-tail}				&	:=		&	$\epsilon$											\\
\atag{lvalue-tail}				&	*		&	$\epsilon$											\\
\atag{lvalue-tail}				&	/		&	$\epsilon$											\\
\atag{lvalue-tail}				&	+		&	$\epsilon$											\\
\atag{lvalue-tail}				&	-		&	$\epsilon$											\\
\atag{lvalue-tail}				&	$=$		&	$\epsilon$											\\
\atag{lvalue-tail}				&	$<$		&	$\epsilon$											\\
\atag{lvalue-tail}				&	$>$		&	$\epsilon$											\\
\atag{lvalue-tail}				&	$<=$		&	$\epsilon$											\\
\atag{lvalue-tail}				&	$>=$		&	$\epsilon$											\\
\atag{lvalue-tail}				&	$<>$		&	$\epsilon$											\\
\atag{lvalue-tail}				&	\&		&	$\epsilon$											\\
\atag{lvalue-tail}				&	\textbar		&	$\epsilon$											\\
\atag{lvalue-tail}				&	)		&	$\epsilon$											\\
\atag{lvalue-tail}				&	,		&	$\epsilon$											\\
\atag{lvalue-tail}				&	]		&	$\epsilon$											\\
\atag{lvalue-tail}				&	then		&	$\epsilon$											\\
\atag{lvalue-tail}				&	do		&	$\epsilon$											\\
\atag{lvalue-tail}				&	to		&	$\epsilon$											\\
\atag{lvalue-tail}				&	;		&	$\epsilon$											\\
\atag{mulop}						&	*		&	*													\\
\atag{mulop}						&	/		&	/													\\
\atag{optional-init}				&	:=		&	:= \atag{const}	\\
\atag{optional-init}				&	;		& $\epsilon$		\\
\atag{orexpr} 					&	(			&	\atag{andexpr} \atag{orexpr-tail}	\\
\atag{orexpr} 					&	nil			&	\atag{andexpr} \atag{orexpr-tail}	\\
\atag{orexpr} 					&	STRLIT			&	\atag{andexpr} \atag{orexpr-tail}	\\
\atag{orexpr} 					&	INTLIT			&	\atag{andexpr} \atag{orexpr-tail}	\\
\atag{orexpr} 					&	id			&\atag{andexpr} \atag{orexpr-tail}		\\
\atag{orexpr} 					&	-			&	\atag{andexpr} \atag{orexpr-tail}	\\
\atag{orexpr-tail}				&	\& 		&	\atag{andop} \atag{andexpr} \atag{orexpr-tail}	\\
\atag{orexpr-tail}				&	 \textbar		&	$\epsilon$	\\
\atag{orexpr-tail}				&	 )		&	$\epsilon$	\\
\atag{orexpr-tail}				&	 ,		&	$\epsilon$	\\
\atag{orexpr-tail}				&	 ]		&	$\epsilon$	\\
\atag{orexpr-tail}				&	 then		&	$\epsilon$	\\
\atag{orexpr-tail}				&	 do		&	$\epsilon$	\\
\atag{orexpr-tail}				&	 to		&	$\epsilon$	\\
\atag{orexpr-tail}				&	 ;		&	$\epsilon$	\\
\atag{orop} 						&	\textbar		&	\textbar	\\
\atag{param}						&	id		&	id : \atag{type-id}		\\
\atag{param-list}				&	)		&	$\epsilon$	\\
\atag{param-list}				&	id		&	\atag{param}	 \atag{param-list-tail}	\\
\atag{param-list-tail}			&	)		&	$\epsilon$	\\
\atag{param-list-tail}			&	,		&	, \atag{param} \atag{param-list-tail}	\\
\atag{ret-type}					&	begin	&	$\epsilon$	\\
\atag{ret-type}					&	:		&	: \atag{type-id}		\\
\atag{stat-assign}				&	id		&	id \atag{stat-assign-id}		\\
\atag{stat-assign}				&	-		&	- \atag{unaryminus} \atag{stat-assign-tail}		\\
\atag{stat-assign}				&	(		&	( \atag{expr} ) \atag{stat-assign-tail}		\\
\atag{stat-assign}				&	nil		&	\atag{const}	 \atag{stat-assign-tail}		\\
\atag{stat-assign}				&	STRLIT		&	\atag{const}	 \atag{stat-assign-tail}		\\
\atag{stat-assign}				&	INTLIT		&	\atag{const}	 \atag{stat-assign-tail}		\\
\atag{stat-assign-id}			&	;			&	$\epsilon$			\\
\atag{stat-assign-id}			&	\textbar		&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	\&			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	$<>$			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	$>=$			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	$<=$			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	$>$			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	$<$			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	$=$			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	-			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	+			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	/			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	*			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	[			&	\atag{lvalue-tail} \atag{stat-assign-tail}			\\
\atag{stat-assign-id}			&	(			&	( \atag{expr-list} )			\\
\atag{stat-assign-tail}			&	;			&	$\epsilon$	\\
\atag{stat-assign-tail}			&	\textbar		&	\atag{expr-tail}	\\
\atag{stat-assign-tail}			&	\&			&	\atag{orexpr-tail}	\\
\atag{stat-assign-tail}			&	$<>$			&	\atag{andexpr-tail}	\\
\atag{stat-assign-tail}			&	$>=$			&	\atag{andexpr-tail}	\\
\atag{stat-assign-tail}			&	$<=$			&	\atag{andexpr-tail}	\\
\atag{stat-assign-tail}			&	$>$			&	\atag{andexpr-tail}	\\
\atag{stat-assign-tail}			&	$<$			&	\atag{andexpr-tail}	\\
\atag{stat-assign-tail}			&	$=$			&	\atag{andexpr-tail}	\\
\atag{stat-assign-tail}			&	-			&	\atag{compare-tail}	\\
\atag{stat-assign-tail}			&	+			&	\atag{compare-tail}	\\
\atag{stat-assign-tail}			&	/			&	\atag{term-tail}	\\
\atag{stat-assign-tail}			&	*			&	\atag{term-tail}	\\
\atag{stat-func-or-assign}		&	(		&	( \atag{expr-list} ) ;	\\
\atag{stat-func-or-assign}		&	:=		&	\atag{lvalue-tail} := \atag{stat-assign}	;	\\
\atag{stat-func-or-assign}		&	[		&	\atag{lvalue-tail} := \atag{stat-assign}	;	\\
\atag{stat-if-tail}				&	else		&	else \atag{stat-seq} endif ;	\\
\atag{stat-if-tail}				&	endif	&	endif ;	\\
\atag{stat}						&	if		&	if \atag{expr} then \atag{stat-seq} \atag{stat-if-tail}		\\
\atag{stat}						&	while	&	while \atag{expr} do \atag{stat-seq} enddo ;		\\
\atag{stat}						&	for		&	for id := \atag{expr} to \atag{expr} do \atag{stat-seq} enddo ;		\\
\atag{stat}						&	break	&	break ;			\\
\atag{stat}						&	return	&	return \atag{expr} ;		\\
\atag{stat}						&	id		&	id \atag{stat-func-or-assign}		\\
\atag{stat-seq}					&	if		&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq}					&	while	&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq}					&	for		&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq}					&	break	&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq}					&	return	&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq}					&	id		&	\atag{stat} \atag{stat-seq-tail}		\\
\atag{stat-seq-tail}				&	endif		&	$\epsilon$	\\
\atag{stat-seq-tail}				&	end			&	$\epsilon$	\\
\atag{stat-seq-tail}				&	enddo		&	$\epsilon$	\\
\atag{stat-seq-tail}				&	else			&	$\epsilon$	\\
\atag{stat-seq-tail}				&	if			&	\atag{stat} \atag{stat-seq-tail}	\\
\atag{stat-seq-tail}				&	while			&	\atag{stat} \atag{stat-seq-tail}	\\
\atag{stat-seq-tail}				&	for			&	\atag{stat} \atag{stat-seq-tail}	\\
\atag{stat-seq-tail}				&	break			&	\atag{stat} \atag{stat-seq-tail}	\\
\atag{stat-seq-tail}				&	return			&	\atag{stat} \atag{stat-seq-tail}	\\
\atag{stat-seq-tail}				&	id			&	\atag{stat} \atag{stat-seq-tail}	\\
\atag{term}				&	-		&	\atag{factor} \atag{term-tail}		\\
\atag{term}				&	id		&	\atag{factor} \atag{term-tail}		\\
\atag{term}				&	INTLIT	&	\atag{factor} \atag{term-tail}		\\
\atag{term}				&	STRLIT	&	\atag{factor} \atag{term-tail}		\\
\atag{term}				&	nil		&	\atag{factor} \atag{term-tail}		\\
\atag{term}				&	(		&	\atag{factor} \atag{term-tail}		\\
\atag{term-tail}					&	*		&	\atag{mulop} \atag{factor} \atag{term-tail}		\\
\atag{term-tail}					&	/		&	\atag{mulop} \atag{factor} \atag{term-tail}		\\
\atag{term-tail}					&	)		&	$\epsilon$		\\
\atag{term-tail}					&	\textbar		&	$\epsilon$		\\
\atag{term-tail}					&	\&		&	$\epsilon$		\\
\atag{term-tail}					&	-		&	$\epsilon$		\\
\atag{term-tail}					&	+		&	$\epsilon$		\\
\atag{term-tail}					&	$<>$		&	$\epsilon$		\\
\atag{term-tail}					&	$>=$		&	$\epsilon$		\\
\atag{term-tail}					&	$<=$		&	$\epsilon$		\\
\atag{term-tail}					&	$>$		&	$\epsilon$		\\
\atag{term-tail}					&	$<$		&	$\epsilon$		\\
\atag{term-tail}					&	$=$		&	$\epsilon$		\\
\atag{term-tail}					&	;		&	$\epsilon$		\\
\atag{term-tail}					&	to		&	$\epsilon$		\\
\atag{term-tail}					&	do		&	$\epsilon$		\\
\atag{term-tail}					&	then		&	$\epsilon$		\\
\atag{term-tail}					&	]		&	$\epsilon$		\\
\atag{term-tail}					&	,		&	$\epsilon$		\\
\atag{tiger-program}				&	let		&	let \atag{declaration-segment} in \atag{stat-seq} end	\\
\atag{type}						&	array		&	array [ INTLIT ] \atag{type-dim} of \atag{type-id}	\\
\atag{type}						&	id		&	\atag{type-id}	\\
\atag{type-declaration-list}		&	type		&	\atag{type-declaration} \atag{type-declaration-list}	\\
\atag{type-declaration-list}		&	var		&	$\epsilon$	\\
\atag{type-declaration-list}		&	function		&	$\epsilon$\\
\atag{type-declaration-list}		&	in		&	$\epsilon$\\
\atag{type-declaration}			&	type 	&	type id = \atag{type} ;		\\
\atag{type-dim}					&	[		&	[ INTLIT ] \atag{type-dim}	\\
\atag{type-dim}					&	of	&	$\epsilon$	\\
\atag{type-id}					&	id		&	id	\\
\atag{unaryminus}				&	(		&	( \atag{expr} )	\\
\atag{unaryminus}				&	nil		&	\atag{const}	\\
\atag{unaryminus}				&	STRLIT		&	\atag{const}	\\
\atag{unaryminus}				&	INTLIT		&	\atag{const}	\\
\atag{unaryminus}				&	id		&	\atag{lvalue}		\\
\atag{var-declaration-list}		&	function		&	$\epsilon$	\\
\atag{var-declaration-list}		&	in	&		$\epsilon$		\\
\atag{var-declaration-list}		&	var		& 	\atag{var-declaration} \atag{var-declaration-list}		\\
\atag{var-declaration}			&	var 		&	var \atag{id-list} : \atag{type-id} \atag{optional-init} ;	\\
\end{longtable}


\end{document}